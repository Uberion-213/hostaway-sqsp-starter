<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>
<script>
(async function () {
  // If you're using the iframe (recommended), keep '/api'.
  // If you pasted this widget directly into Squarespace (no iframe),
  // set apiBase to 'https://YOUR-APP.vercel.app/api'
  const apiBase = '/api';

  // 1) populate listings
  const listingsResp = await fetch(`${apiBase}/listings`);
  const listingsJson = await listingsResp.json();
  const listings = listingsJson.result?.result || listingsJson.result || [];
  const select = document.getElementById('listingSelect');
  listings.forEach(l => {
    const opt = document.createElement('option');
    opt.value = JSON.stringify({ listingId: l.id, listingMapId: l.listingMapId });
    opt.textContent = l.name || `Listing ${l.id}`;
    select.appendChild(opt);
  });

  // 2) init calendar
  const calEl = document.getElementById('calendar');
  const calendar = new FullCalendar.Calendar(calEl, {
    initialView: 'dayGridMonth',
    selectable: true
  });
  calendar.render();

  // Keep latest availability days around (for basic validation)
  let lastDays = [];

  // 3) load + shade unavailable days (booked/blocked)
  async function refreshCalendar() {
    const { listingId } = JSON.parse(select.value);

    // show a longer window so booked days are visible
    const start = new Date();
    const end = new Date(); end.setMonth(end.getMonth() + 12);

    const s = start.toISOString().slice(0,10);
    const e = end.toISOString().slice(0,10);

    const resp = await fetch(`${apiBase}/availability?listingId=${listingId}&start=${s}&end=${e}`);
    const data = await resp.json();

    // payload shape can vary: prefer result.calendar, fallback to calendar
    const days = data?.result?.calendar ?? data?.calendar ?? [];
    lastDays = days;

    // mark a day unavailable if any of these flags indicate booked/blocked
    const unavailable = days.filter(d =>
      d.isAvailable === 0 ||
      d.available === 0 ||
      d.isBlocked === 1 ||
      d.status === 'booked' ||
      d.status === 'blocked' ||
      (typeof d.reservationId !== 'undefined' && d.reservationId !== null)
    ).map(d => {
      // FullCalendar background events use an exclusive end → add 1 day
      const startStr = d.date;                  // "YYYY-MM-DD"
      const endDate = new Date(d.date);
      endDate.setDate(endDate.getDate() + 1);
      const endStr = endDate.toISOString().slice(0,10);
      return { start: startStr, end: endStr, display: 'background' };
    });

    calendar.removeAllEvents();
    if (unavailable.length) calendar.addEventSource(unavailable);

    // optional on-screen status (safe if element missing)
    const statusEl = document.getElementById('status');
    if (statusEl) statusEl.textContent =
      `Loaded ${days.length} days • shaded ${unavailable.length} unavailable`;
  }

  select.addEventListener('change', refreshCalendar);
  await refreshCalendar();

  // 4) pricing flow
  const quoteForm = document.getElementById('quoteForm');
  const quoteResult = document.getElementById('quoteResult');
  const guestForm = document.getElementById('guestForm');
  let lastQuote = null;

  quoteForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const { listingMapId } = JSON.parse(select.value);
    const startingDate = document.getElementById('startDate').value;
    const endingDate = document.getElementById('endDate').value;
    const numberOfGuests = parseInt(document.getElementById('guests').value, 10);

    // basic guard: prevent quoting if the selected range hits a blocked day
    const sT = new Date(startingDate).getTime();
    const eT = new Date(endingDate).getTime();
    const rangeHasBlocked = lastDays.some(d => {
      const blocked = (d.isAvailable === 0 || d.available === 0 || d.isBlocked === 1 ||
                       d.status === 'booked' || d.status === 'blocked' ||
                       (typeof d.reservationId !== 'undefined' && d.reservationId !== null));
      if (!blocked) return false;
      const dT = new Date(d.date).getTime();
      return dT >= sT && dT < eT;
    });
    if (rangeHasBlocked) {
      alert('Those dates include a blocked day. Please choose different dates.');
      return;
    }

    const q = await fetch(`${apiBase}/price`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ listingMapId, startingDate, endingDate, numberOfGuests })
    }).then(r => r.json());

    const total = q?.result?.totalPrice ?? q?.totalPrice;
    const components = q?.result?.components ?? q?.components ?? [];
    const fmt = new Intl.NumberFormat(undefined, { style:'currency', currency:'USD' });

    lastQuote = { listingMapId, startingDate, endingDate, numberOfGuests, totalPrice: total, components };
    quoteResult.textContent =
      `Total: ${fmt.format(total)}\n\nBreakdown:\n` +
      components.map(c => `${c.title || c.name}: ${fmt.format(c.total)}`).join('\n');

    guestForm.style.display = 'block';
  });

  // 5) create reservation
  guestForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const payload = {
      ...lastQuote,
      guestFirstName: document.getElementById('firstName').value,
      guestLastName: document.getElementById('lastName').value,
      guestEmail: document.getElementById('email').value,
      guestPhone: document.getElementById('phone').value
    };
    const res = await fetch(`${apiBase}/reservations`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).then(r => r.json());

    alert('Reservation created! ID: ' + (res?.result?.id || res?.result?.reservation?.id || res?.id || 'OK'));
    // Optional redirect:
    // window.location.href = '/thank-you';
  });
})();
</script>

